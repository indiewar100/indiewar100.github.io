<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>indiewar&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/53949e89f0ed2e36daef75fd81b5b8e1</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-21T06:53:50.067Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>indiewar</name>
    <email>indiewar100@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>new start</title>
    <link href="http://yoursite.com/2020/01/21/new-start/"/>
    <id>http://yoursite.com/2020/01/21/new-start/</id>
    <published>2020-01-21T06:05:37.000Z</published>
    <updated>2020-01-21T06:53:50.067Z</updated>
    
    <content type="html"><![CDATA[<p>把之前的东西全删了，又随手搬了一些东西过来。从秦皇岛参加camp回来就决定正式退役了。回顾过去，是很失败的竞赛生涯，一个ecfinal的铜和其他邀请赛之类的铜没有将我打败，然而或许是参加A Day With Google时大佬随口说的一句话，或许是camp上的所见所闻，我决定正式告别了，似乎有很多很多想说的东西，之后可能会写一篇退役感想。</p><p>不太清楚以后会更新什么样的内容，或许还会写算法，或许会更新一些其他的东西，anyway，最后放一些在camp时拍的海。</p><p><img src="/images/6.jpg" alt><br><img src="/images/5.jpg" alt><br><img src="/images/4.jpg" alt><br><img src="/images/3.jpg" alt><br><img src="/images/2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把之前的东西全删了，又随手搬了一些东西过来。从秦皇岛参加camp回来就决定正式退役了。回顾过去，是很失败的竞赛生涯，一个ecfinal的铜和其他邀请赛之类的铜没有将我打败，然而或许是参加A Day With Google时大佬随口说的一句话，或许是camp上的所见所闻，我决
      
    
    </summary>
    
      <category term="随想" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="记" scheme="http://yoursite.com/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019 Multi-University, Nowcoder Day 1 E.ABBA</title>
    <link href="http://yoursite.com/2019/07/19/2019-Multi-University-Nowcoder-Day-1-E-ABBA/"/>
    <id>http://yoursite.com/2019/07/19/2019-Multi-University-Nowcoder-Day-1-E-ABBA/</id>
    <published>2019-07-19T02:24:31.000Z</published>
    <updated>2020-01-21T05:43:44.336Z</updated>
    
    <content type="html"><![CDATA[<p>考虑题目的约束条件<br>对于任何合法情况的前缀应满足</p><ul><li>$A&lt;=n+B$</li><li>$B&lt;=A+m$</li></ul><p>解释</p><ul><li>贪心，A 肯定是先用 AB 的 A，再用 BA 的 A；B 同理 </li><li>更本质的性质是对于任何前缀,当前A的最大值只能是选完所有的A,然后B全部来自BA(这样才能有更多的A可以选择),B同理</li></ul><p>转化问题,变成从(0,0)到(n+m,n+m)的网格问题,再减去不合法的情况<br>设x坐标表示A的值,y坐标表示B的值<br>则约束条件转化为</p><ul><li>$x &lt;= y+n$</li><li>$y &lt;= x+m$</li></ul><p>即不能穿过两条直线，如图所示<br><img src="/images/1.png" alt><br>阴影部分为合法区域<br>关于不合法的计算，就是平移，对称的技巧运用<br>例如下面的直线$y=x-n$，平移1，得到$y=x-n-1$（平移是因为要穿过直线，在直线上也是合法情况），对称点为$(n+1,-(n+1))$，这样$(0,0)$到$(2 \cdot (n+m),n+m)$穿过 $y=x-n$的情况就变成 $(n+1,-(n+1))$到$(2\cdot(n+m),n+m)$的情况</p><p>结果为<br>$ C(2\cdot(n+m),n+m)-C(2\cdot(n+m),m-1)-C(2\cdot(n+m),n-1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; assert(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line">ll fac[maxn],invf[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123; <span class="comment">// n &gt;= m &gt;= 0</span></span><br><span class="line">    <span class="keyword">return</span> n &lt; m || m &lt; <span class="number">0</span> ? <span class="number">0</span> : fac[n] * invf[m] % mod * invf[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>]=invf[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,<span class="number">4001</span>) fac[i]=fac[i<span class="number">-1</span>]*i%mod,invf[i]=powmod(fac[i],mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);</span></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">ans = C(<span class="number">2</span>*(n+m),n+m);</span><br><span class="line">ans -= C(<span class="number">2</span>*(n+m),n<span class="number">-1</span>);</span><br><span class="line">ans -= C(<span class="number">2</span>*(n+m),m<span class="number">-1</span>);</span><br><span class="line">ans = (ans%mod+mod)%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考虑题目的约束条件&lt;br&gt;对于任何合法情况的前缀应满足&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$A&amp;lt;=n+B$&lt;/li&gt;
&lt;li&gt;$B&amp;lt;=A+m$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贪心，A 肯定是先用 AB 的 A，再用 BA 的 A；B 同理 
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="组合数学" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>智商恢复训练(中位数)</title>
    <link href="http://yoursite.com/2019/01/31/%E6%99%BA%E5%95%86%E6%81%A2%E5%A4%8D%E8%AE%AD%E7%BB%83-%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2019/01/31/智商恢复训练-中位数/</id>
    <published>2019-01-30T16:01:41.000Z</published>
    <updated>2020-01-21T06:02:00.050Z</updated>
    
    <content type="html"><![CDATA[<p>在一个有序序列里，中位数有一些很优美的性质。</p><p><strong>1</strong><br><strong>货仓选址</strong><br>在一条数轴上有$N$家商店，它们的坐标分别为 $A_1…A_N$。<br>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p><p>我们设在仓库左边的点有p个,右边的有q个，若p &lt; q,当仓库向右移动的话，距离之和会减少，如p＞q ,当仓库向左移动的话，距离之和会减少，所以说当p = q时为最优解。因此货仓建在中位数处。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>+<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">rep(i,<span class="number">0</span>,n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line"><span class="keyword">int</span> mid = a[(n+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">rep(i,<span class="number">0</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">ans += <span class="built_in">abs</span>(a[i] - mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>均分纸牌</strong><br>有$N$堆纸牌，编号分别为 $1,2,…,N$。每堆上有若干张，但纸牌总数必为$N$的倍数。可以在任一堆上取若干张纸牌，然后移动。<br>移牌规则为：在编号为$1$堆上取的纸牌，只能移到编号为$2$的堆上；在编号为$N$的堆上取的纸牌，只能移到编号为$N-1$的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。<br>现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。</p><p>假如每次只能移动一个<br>$ans = \sum_{i = 1}^{N}|S[i]|$ 其中S是A的前缀和$s[i] = \sum_{j=1}^{i}A[j]$<br>$A[i] = c[i]-T/N$<br>对于这题，只需要判断$S[i]$不等于0的情况加一<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line">sum /= n;</span><br><span class="line"><span class="comment">// printf("%lld\n",sum);</span></span><br><span class="line">rep(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] -= sum;</span><br><span class="line">f[i] = f[i<span class="number">-1</span>] + a[i];</span><br><span class="line"><span class="keyword">if</span>(!f[i]) <span class="keyword">continue</span>;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rep(i,1,n+1)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// ans += abs(f[i]);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>BZOJ 1045 环形均分纸牌</strong><br>想普通的均分纸牌，断一下就能得到答案<br>$ans = \sum_{i = 1}^{N}|S[i]-S[k]|$<br>需要枚举K吗？想一想第一个题，$S\lbrack k \rbrack$为中位数时最优<br>注意此题的数据范围<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line">sum /= n;</span><br><span class="line"></span><br><span class="line">rep(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] -= sum;</span><br><span class="line">a[i] += a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">ll mid = a[(n+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans += <span class="built_in">abs</span>(a[i]-mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>[BZOJ3032]七夕祭（中位数）</strong><br>分割成行和列两个独立的子问题<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn],s1[maxn],s2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,T;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;T);</span><br><span class="line"></span><br><span class="line">    rep(i,<span class="number">1</span>,T+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        x[a]++,y[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T%m!=<span class="number">0</span> &amp;&amp; T%n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n+<span class="number">1</span>) x[i]-=T/n;</span><br><span class="line">    rep(i,<span class="number">1</span>,m+<span class="number">1</span>) y[i]-=T/m;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T%n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rep(i,<span class="number">1</span>,n+<span class="number">1</span>) </span><br><span class="line">        s1[i]=s1[i<span class="number">-1</span>]+x[i];</span><br><span class="line">        sort(s1+<span class="number">1</span>,s1+n+<span class="number">1</span>);</span><br><span class="line">        ll mid=s1[(n+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">        rep(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">            ans+=<span class="built_in">abs</span>(s1[i]-mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T%m==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rep(i,<span class="number">1</span>,m+<span class="number">1</span>)</span><br><span class="line">        s2[i]=s2[i<span class="number">-1</span>]+y[i];</span><br><span class="line">        sort(s2+<span class="number">1</span>,s2+m+<span class="number">1</span>);</span><br><span class="line">        ll mid=s2[(m+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">        rep(i,<span class="number">1</span>,m+<span class="number">1</span>)</span><br><span class="line">            ans+=<span class="built_in">abs</span>(s2[i]-mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T%n==<span class="number">0</span> &amp;&amp; T%m==<span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"both "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T%n==<span class="number">0</span> &amp;&amp; T%m!=<span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"row "</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"column "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个有序序列里，中位数有一些很优美的性质。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;货仓选址&lt;/strong&gt;&lt;br&gt;在一条数轴上有$N$家商店，它们的坐标分别为 $A_1…A_N$。&lt;br&gt;现在需要在数轴上建立一家货仓，每天清晨，从货仓
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>SG函数总结(入门向+简单数学证明)</title>
    <link href="http://yoursite.com/2018/07/18/SG%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93-%E5%85%A5%E9%97%A8%E5%90%91-%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/"/>
    <id>http://yoursite.com/2018/07/18/SG函数总结-入门向-简单数学证明/</id>
    <published>2018-07-18T11:13:06.000Z</published>
    <updated>2020-01-21T06:03:12.488Z</updated>
    
    <content type="html"><![CDATA[<p>在谈SG函数之前，我们先看一个关于有向图游戏的定义。<br>   <strong>有向图游戏</strong></p><blockquote><p>给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。</p></blockquote><p>事实上我们可以发现<strong>任何一个ICG(公平组合游戏)都可以转化成有向图游戏</strong>。具体方法为，把每个局面看成图的一个节点，并且从每个局面向能到达的局面连有向边。</p><p>然后我们再来了解一个Mex运算。<br><strong>Mex(minimal excludant)运算</strong></p><blockquote><p><a href="https://en.wikipedia.org/wiki/Mex_(mathematics" target="_blank" rel="noopener">Mex wiki</a>)<br>In mathematics, the mex of a subset of a well-ordered set is the smallest value from the whole set that does not belong to the subset. That is, it is the minimum value of the complement set. The name “mex” is shorthand for “minimum excluded” value.</p></blockquote><p>我们这里可以简单点理解，给一个非负整数集合S，mex(S)为求出<strong>不属于集合S</strong>的<strong>最小</strong>非负整数的运算。例如$mex(0,1,2,4,5)=3$、 $mex(2,3,5)=0$、$mex()=0$</p><p>接着就到了本文的核心，SG函数</p><h1 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a><strong>SG函数</strong></h1><blockquote><p>对于一个给定的有向无环图，定义关于图的每个顶点的SG函数SG如下，<strong>$SG(x)$= $mex$({ $SG(y1)$ ,$SG(y2)$,…,$SG(yk)$})     ($y$是$x$的后继) </strong>。</p></blockquote><p>我们怎么理解这个函数呢？在有向图游戏中，对于每个节点$x$，设从$x$出发共有$k$条有向边，分别到达节点$y1$,$y2$,…,$yk$，$SG(x)$为$x$的后继节点的$SG$函数值构成的集合再执行$mex$运算的结果为该节点$x$的$SG$函数值<br><strong>整个有向图游戏$G$的$SG$函数值被定义为有向图游戏起点的$SG$函数值</strong></p><h2 id="有向图游戏的和"><a href="#有向图游戏的和" class="headerlink" title="有向图游戏的和"></a>有向图游戏的和</h2><blockquote><p><strong>有向图游戏的和的$SG$函数值等于它包含的各个子游戏$SG$函数值的异或值</strong></p></blockquote><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><blockquote><p>有向图游戏的某个局面<strong>必胜</strong>，<strong><em>当且仅当</em></strong>该局面对应节点的$SG$函数值大于0<br>有向图游戏的某个局面<strong>必败</strong>，<strong><em>当且仅当</em></strong>该局面对应节点的$SG$函数值等于0</p></blockquote><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem" target="_blank" rel="noopener">Sprague–Grundy_theorem Wiki</a></p></blockquote><p>这里给出一点简单的个人理解：<br> <em>1</em>.在一个<strong>没有出边</strong>的节点$s$上，棋子不能移动，$SG(s)$ $=$ $0$ ,对应P局面</p><p> <em>2</em>.一个节点$k$的$SG$函数值<strong>大于$0$</strong>，则其后继节点必有一个节点$s$的$SG$函数值等于$0$，由1得节点s对应P局面，则当前节点k对应的局面为N局面</p><p> <em>3</em>.一个节点的后继节点$SG$函数值均不为$0$，则该节点的$SG$函数值为$0$。可推出<strong>若一个局面的后继局面全部为N局面，则当前局面为P局面</strong>。</p><p>以下为SimonS大佬的$SG$函数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">define MAX <span class="number">1005</span></span><br><span class="line"><span class="comment">/* 计算从1-n范围内的SG值。</span></span><br><span class="line"><span class="comment">   Array(存储可以走的步数，Array[0]表示可以有多少种走法)</span></span><br><span class="line"><span class="comment">   Array[]需要从小到大排序 */</span></span><br><span class="line"><span class="comment">/*HDU1847博弈SG函数</span></span><br><span class="line"><span class="comment">1.可选步数为1-m的连续整数，直接取模即可，SG(x) = x % (m+1);</span></span><br><span class="line"><span class="comment">2.可选步数为任意步，SG(x) = x;</span></span><br><span class="line"><span class="comment">3.可选步数为一系列不连续的数，用GetSG(计算) */</span></span><br><span class="line"><span class="keyword">int</span> SG[MAX], hash[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetSG</span><span class="params">(<span class="keyword">int</span> Array[],<span class="keyword">int</span> n = MAX<span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(SG, <span class="number">0</span>, <span class="keyword">sizeof</span>(SG));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(hash, <span class="number">0</span>, <span class="keyword">sizeof</span>(hash));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Array[<span class="number">0</span>]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; Array[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            hash[SG[i - Array[j]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!hash[j])</span><br><span class="line">            &#123;</span><br><span class="line">                SG[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>基于lyd的&lt;&lt;算法竞赛进阶指南&gt;&gt;和部分集训队论文写成</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在谈SG函数之前，我们先看一个关于有向图游戏的定义。&lt;br&gt;   &lt;strong&gt;有向图游戏&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="博弈论" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
</feed>
